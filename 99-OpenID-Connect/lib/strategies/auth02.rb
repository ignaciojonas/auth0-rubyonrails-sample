require 'jwt'
require 'omniauth'
require 'openssl'
require 'securerandom'

module OmniAuth
  module Strategies
    class Auth02
      include OmniAuth::Strategy

      class OAuthError < StandardError; end

      args [:client_id, :client_secret, :namespace, :provider_ignores_state, :connection]

      # Field renaming is an attempt to fit the OmniAuth recommended schema as
      # best as possible.
      #
      # @see https://github.com/intridea/omniauth/wiki/Auth-Hash-Schema
      uid { @claims['sub'] }
      info do
        { name: @claims['name'],
          email: @claims['email'],
          image: @claims['picture'] }
      end

      credentials { { code: @code } }
      extra do
        { session_state: @session_state,
          raw_info:
            { id_token: @id_token,
              id_token_claims: @claims,
              id_token_header: @header } }
      end

      #DEFAULT_RESPONSE_TYPE = 'code id_token'.freeze
      DEFAULT_RESPONSE_TYPE = 'id_token'.freeze
      DEFAULT_RESPONSE_MODE = 'form_post'.freeze

      ##
      # Overridden method from OmniAuth::Strategy. This is the first step in the
      # authentication process.
      def request_phase
        redirect authorize_endpoint_url
      end

      ##
      # Overridden method from OmniAuth::Strategy. This is the second step in
      # the authentication process. It is called after the user enters
      # credentials at the authorization endpoint.
      def callback_phase
        error = request.params['error_reason'] || request.params['error']
        raise(OAuthError, error) if error
        @session_state = request.params['session_state']
        @id_token = request.params['id_token']
        #@code = request.params['code']
        @claims, @header = validate_and_parse_id_token(@id_token)
        #validate_chash(@code, @claims, @header)
      super
      end

      ##
      # Constructs a one-time-use authorize_endpoint. This method will use
      # a new nonce on each invocation.
      #
      # @return String
      def authorize_endpoint_url
        uri = URI("https://#{ENV['AUTH0_DOMAIN']}/authorize")
        uri.query = URI.encode_www_form(client_id: client_id,
                                        redirect_uri: callback_url,
                                        response_mode: response_mode,
                                        response_type: response_type,
                                        scope: 'openid name email picture profile',
                                        nonce: new_nonce)
        uri.to_s
      end

      ##
      # The client id of the calling application. This must be configured where
      # AzureAD is installed as an OmniAuth strategy.
      #
      # @return String
      def client_id
        ENV['AUTH0_CLIENT_ID']
      end

      # ##
      # # The callback url.
      # #
      # # @return String
      def callback_url
        'http://localhost:3000/auth/auth0/callback'
      end

      ##
      # Generates a new nonce for one time use. Stores it in the session so
      # multiple users don't share nonces. All nonces should be generated by
      # this method.
      #
      # @return String
      def new_nonce
        session['auth0.nonce'] = SecureRandom.uuid
      end

      ##
      # Returns the most recent nonce for the session and deletes it from the
      # session.
      #
      # @return String
      def read_nonce
        session.delete('auth0.nonce')
      end

      ##
      # The response_type that will be set in the authorization request query
      # parameters. Can be overridden by the client, but it shouldn't need to
      # be.
      #
      # @return String
      def response_type
        options[:response_type] || DEFAULT_RESPONSE_TYPE
      end

      ##
      # The response_mode that will be set in the authorization request query
      # parameters. Can be overridden by the client, but it shouldn't need to
      # be.
      #
      # @return String
      def response_mode
        options[:response_mode] || DEFAULT_RESPONSE_MODE
      end

      ##
      # # The key used to sign the id token JWTs.
      # #
      # # @return String
      def signing_key
        JWT.base64url_decode(ENV['AUTH0_CLIENT_SECRET'])
      end

      ##
      # Verifies the signature of the id token as well as the exp, nbf, iat,
      # iss, and aud fields.
      #
      # See OpenId Connect Core 3.1.3.7 and 3.2.2.11.
      #
      # @return Claims, Header
      def validate_and_parse_id_token(id_token)
          # The second parameter is the public key to verify the signature.
          # However, that key is overridden by the value of the executed block
          # if one is present.
          #
          # If you're thinking that this looks ugly with the raw nil and boolean,
          # see https://github.com/jwt/ruby-jwt/issues/59.
          jwt_claims, jwt_header =
          JWT.decode(id_token, signing_key, true, verify_options) #do |header|
            # There should always be one key from the discovery endpoint that
            # matches the id in the JWT header.
            # x5c = (signing_keys.find do |key|
            #   key['kid'] == header['kid']
            # end || {})['x5c']
            # if x5c.nil? || x5c.empty?
            #   raise JWT::VerificationError,
            #         'No keys from key endpoint match the id token'
            # end
            # The key also contains other fields, such as n and e, that are
            # redundant. x5c is sufficient to verify the id token.
            #OpenSSL::X509::Certificate.new(JWT.base64url_decode(x5c.first)).public_key
            #OpenSSL::X509::Certificate.new(JWT.base64url_decode(signing_key)).public_key
          #end
          return jwt_claims, jwt_header if jwt_claims['nonce'] == read_nonce
          #return jwt_claims, jwt_header if jwt_claims['nonce'] == 'nonce'
          raise JWT::DecodeError, 'Returned nonce did not match.'
        end

      ##
      # Verifies that the c_hash the id token claims matches the authorization
      # code. See OpenId Connect Core 3.3.2.11.
      #
      # @param String code
      # @param Hash claims
      # @param Hash header
      def validate_chash(code, claims, header)
        # This maps RS256 -> sha256, ES384 -> sha384, etc.
        algorithm = (header['alg'] || 'RS256').sub(/RS|ES|HS/, 'sha')
        full_hash = OpenSSL::Digest.new(algorithm).digest code
        c_hash = JWT.base64url_encode full_hash[0..full_hash.length / 2 - 1]
        return if c_hash == claims['c_hash']
        raise JWT::VerificationError,
              'c_hash in id token does not match auth code.'
      end

      ##
      # The options passed to the Ruby JWT library to verify the id token.
      # Note that these are not all the checks we perform. Some (like nonce)
      # are not handled by the JWT API and are checked manually in
      # #validate_and_parse_id_token.
      #
      # @return Hash
      def verify_options
        {
          #verify_expiration: true,
          #verify_not_before: true,
          #verify_iat: true,
          #verify_iss: true,
          #'iss' => issuer,
          algorithm: 'HS256',
          verify_aud: true,
          'aud' => client_id
        }
      end
    end
  end
end
